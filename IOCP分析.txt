所要投递的操作：
		1、投递等待连接操作：RGB(0xd7,0x0b,0xcc)
		何时投递：启动时，在初始化listenSocket以后投递，另外当有客户端连接完成，操作结束时需要再次投递。
		需要什么：绑定服务器的listenSocket，用于和客户端连接的socket，Overlapped，以及缓冲区，
		如何投递：AcceptEx（）；扩展的winsock函数，在MSWSock.h头文件中
		投递个数：对于四道或六道的DMA，我们投递十至十五个接受连接的操作就可以避免--有客户端连接上来时没有连接操作的情况
		
		2、投递接收操作
		何时投递：客户端连接完成时，要为他投递一个接收数据的操作，接收数据完成时，需要再投递一个。
		需要什么：与客户端连接的socket，Overlapped，缓冲区。
		如何投递：WSARecv（）；头文件winsock2.h
		投递个数：一般只投递一个，当用户操作特别频繁时，为了避免在接收到的操作未完成时，客户端又有信息发来，可为一个客户投递					2个或多个，根据所需要的处理复杂度添加。
		
		3、投递-向客户端发送数据-的操作
		何时投递：1、验证客户端是否已断开连接时。2、客户端之间通信时，需要经服务器转发数据时，比如，在接收到一个客户的操作为					向另一个客户端发送数据
		需要什么：与客户端连接的socket，Overlapped，缓冲区。
		如何投递：WSASend();头文件winsock2.h
		投递个数：根据需求任意增加。

对于完成的操作如何处理：
	对于这个问题，需要注意以下两点：1、操作完成后能获取到什么数据，2、这些数据是什么时候放进去的
	对于第一点，很简单，可以得到一个自定义结构的地址和一个Overlapped的地址，具体是什么信息是有第二点决定的。
	什么时候放进去的，在调用CreateIOCP函数时，参数为，文件句柄（此处socket），已有的IOCP，自定义结构，同时运行线程数，调用完成后，不仅把该socket的操作交由IOCP管理，同时也把socket与自定义结构关联起来。在投递操作时，参数至少有，socket与Overlapped的地址。如果挨着Overlapped还放有其他内容的话，自然也是很容易找到的。需要说明的是，acceptEx操作比较复杂，有两个socket和一个Overlapped。
	它返回的内容有点绕，就是listenSocket绑定到IOCP时的自定义结构，Overlapped的地址就是投递acceptEx操作时的那一个
	现在，由这个自定义结构可以找到与你的socket相关的信息，由Overlapped的地址就可以找到与操作相关的信息了。
		1、客户端连接完成，获取到客户端的Ip端口等信息，保存到与客户端对应的socket的PerSocket结构中的地址中。如何找到的问题，我们在池的设计中详细说明。
		需要说明的是，acceptEx()函数可以接收到用户的第一条数据后返回，也可以直接返回，由参数控制。可以根据不同情况使用。
		操作完成后，我们自然要再投递一个接受连接的操作，以等待其他客户的连接。对于已完成连接的socket，我们要为他投递一个接收数据操作，以接受该客户端发来的数据
		2、接受数据操作完成时。我们首先先要知道是谁发来的数据，对于这些数据要如何处理，比如最简单的显示。
		处理完成后，再次投递一个接收数据的操作。
		3、发送数据操作完成后，我们只需知道是否发送完成，完成则把相应的Overlapped结构释放，如果未发送成功，则需要检测错误，
		比如客户端款开链接，则需要释放该socket的所有操作，以及所在的perSock结构。
		
提高服务器大量客户同时连接时的性能   ----   池。
分析以下我们在IOCP模型中出现的各种对象，socket，perSocketContext，perIOContext，Buf，当我们需要用到他们的时候就要为他们开辟空间，而用完之后，这些对象就要马上释放掉，以免内存泄露。如果只有为数不多的客户端在连接，CPU相对还比较轻松时，这些操作自然也不算什么，不过，当同时有大量客户端连接时，CPU一方面要处理各客户端的逻辑操作，另一方面又要为其他客户的连接，客户之间传输数据，准备空间，同时对于完成的操作，以及退出的客户还要释放空间。所以，我们可以考虑用池解决这个问题。也就是把这些要频繁生成和释放的对象保存起来统一管理，一次生成，直到程序结束或确实不会用到他们的时候再释放。这样也就避免了CPU在处理繁忙的逻辑处理时还要去分配空间，创建内核对象的操作。自然，有好处也就有代价，关键是代价是否值得。我们提高效率的同时，对与内存空间的开销也就要大很多。

为了提高效率要建池，那么，要为哪些对象建池？
首先SOCKET内核对象，没连接一个客户端我们就要建一个，客户端下线时释放。对于PC机来说，连接比较稳定，断线情况较少，服务端的对应socket可以一直用到客户端彻底退出，建池虽然也提升性能，但相比于内存的消耗来说并不是很必要。而对于手机客户端来说，特别是移动中的客户端断线重连是很常见的现象。因此，相比于提升的性能来说，占用的那点内存空间就不值一提了。
与socket向对应的便是perSocketContext，他们之间是一一对应的。它是一个用户对象，因此更应该建池
其次便是PerIoConetext池，服务器与客户端特别是大量客户端之间的操作必然是十分频繁的，因此是时分有必要建池来统一管理的。
与之相对应的是Buf（缓冲区），也是很有必要的

由于他们之间存在着一一对应的关系，对于同是用户对象的PerIoSocket和buf合二为一来管理是很方便的。
而socket是内核对象，PerSocketContext是用户对象，是否合并在一起？

我们对于分开和不分开两种情况在操作中进行分析：
首先一个池自然要比两个池方便管理。
其次，对于分开的操作：
1、投递acceptEx时，从socket池中取出socket，从PerIO池中取出PerIo把socket关联到perIO对象，客户端连接时，从perSo	cket池中取出persocket对象，把该socket和perSocket绑定到IOCP中。此时，perIO中和perSocket中都只用存放socket句	柄，把buf中的客户端信息拷贝到perSocket中的sockaddr_in中。可以用此IO结构投递接收数据操作。不过要把该perIO对	象的指针添加到perSocket中该socket所对应的操作数组或链表中。
2、投递WSARecv操作时，此处只投递一个。
3、投递WSASend操作时，从perIo池中取出perIO对象，绑定到该socket，添加到perSocket中-该socket的操作数组或连表-中

对于合并的操作：
1、投递acceptEx时，从perSocketContext池中取出perSocketContext对象，它包含一个有效的socket对象，从perIO池中取	出一个perIO对象，投递操作，客户端连接时，我们的有效数据只有Overlapped相关对象。我们如何找到该socket对应的pe	rSocketContext对象?这就需要我们对perIO中的socket元素略作改变，在perSocket中，我们存放socket的句柄。在perIO	中，我们存放socket句柄的指针。这样我们就完全由一个perIO便可获取了所有的内容，功能很强大，用起来也很复杂呀。	之后的事情，同样需要保存客户端信息，投递接受操作，记录该socket的操作。
2、投递WSARecv操作时，此处只投递一个。
3、投递WSASend操作时，从perIo池中取出perIO对象，绑定到该socket，添加到perSocket中-该socket的操作数组或连表-中



用户分析：
假设一台服务器有一百万用户，一般同时在线人数有十万到二十万，同时登录的人数最大值大概也就在10到20之间。
对于同时数万人同时登录的情况在服务器集群中考虑。

单链表分析：
要求：
		1、具有通用性，即可以处理任何类型的数据。
		2、具备插入元素(分为在首节点后插入，和在节点出插入)，删除元素，查找元素，等操作
		3、生成链表对象时生成首节点，释放连表对象时，清除所有节点的信息。

实现分析：
1、要有通用性,节点应该是以下类型
struct Node
{
	void *pData；
	Node *pNext； 
}
2-3、参见链表设计流程图。

顺序链表与逆序连表的区别：
A-->B-->C-->D     E-->A-->B-->C-->D
A-->B-->C-->D			A-->B-->C-->D-->E
也就是插在首和插在尾的区别。
分别把ABCDE插入连表，
顺序则为：A-->B-->C-->D-->E逆序则为：E-->D-->C-->B-->A。

池的分析：
要求：
1、可以设定大小，即存放元素的数目
2、管理池中的元素，可以从池中获取空闲的元素，某些在使用的元素也可以变为空闲的元素。
   也就是保证每个空闲的元素都可以取出来。
3、判断是否有空闲元素，没有时返回空。
4、因为多出要用，我们可以把它设计为模板

实现分析：
1、若要可设定大小，就要求池中元素的空间是动态申请的。可以在构造函数中new出对应个数的对象。在析构函数中释放该	 对象。
2、建立一个对应大小的数组(下标数组)来保存空闲元素的位置下标。显然数组的长度应该与池中元素(元素数组)的长度是一	 致的，也应该是动态的。初始状态下，池中的元素都是空闲的，下标数组中的元素自然为0到size-1；另外需要为下标数	 组维护一个指向最后一个空闲元素的下标变量。取空闲元素时，只需取出--以-空闲下标指向的下标数组中的元素-为下标	 的元素数组的内容。然后，空闲下标--；元素由忙变闲时，只需把该元素的下标放入到下标数组的空闲下标+1处。
3、因为所有元素都被使用时，我们就无法取出空闲的元素。而下标为-1是不会被编译器报错的。这个问题，必须我们单独处理。

我们如何从一个元素中获取它在数组中的下标？？？
^_^再浪费点空间吧，在每个元素中加一个下标属性。

规定：获取空闲元素失败时返回NULL,无空闲元素时，返回-1.


类设计：
TYPE *pType;										// 池中元素的首地址
int size;												// 池的大小，即池中元素的数目。
int *pIndexArray；							// 下标数组
int indexOfIndexArray;					// 下标数组中最后一个空闲元素的下标。

Type* GetIdleEle();							// 获取空闲元素
void BusytoIdle(int index);			// 指定下标处的元素数组中的元素由忙变闲。
bool IsThereAnyOneIdle();				// 判断是否有空闲元素。

IOCP类设计：
阶段一、
功能需求：
	1、加载运行库，模块相对独立，可单独作为一个函数。
	2、建立IOCP对象，显然许多地方要用到这个唯一的内核对象，要把它作为成员属性。
	3、启动与内核数相当的线程，为增强可扩展性，应当自动获取系统内核数。
	关于线程函数的问题，首先，它必须是标准调用，不能写成成员函数。静态函数可以满足标准调用的要求，不过同样不能满足使用非静态成员属性的要求，需要的内容必须通过传参进行，所需要的主要也就是当前对象指针了。通过传参，静态和全局两种方式都可以满足需求。
	4、建立listenSocket，绑定到本机。为增强可扩展性，应当自动获取本机IP，并且在启动时可选择手动设置端口号。
	5、手动获取acceptEx()函数指针，增加运行效率。
	6、取出一个socket和一个perIo结构，投递acceptEx操作，所以需要两个(or three)池。
	7、当客户端连接上来时，必须要处理连接的请求，要获取客户端的信息，需要有perSocket结构，perIO结构，操作类型结构。
	8、连接完成后需要投递接受操作。
	9、接收数据操作完成后，必须处理接受到的数据；
	10、对于处理数据的结果可能是需要向某个客户端发送消息，所以要投递发送消息操作。
	11、处理发送完成的结果。
	12、工作线程的设计，首先工作线程要能够处理或调用以上的哪些操作，当退出时，需要关闭IOCP，所以必须先激活线程，然后关闭线程。关闭句柄等。
	退出时的问题：首先在线程睡眠状态下关闭线程是一定不可取的，这回导致资源无法得到释放，造成内存泄露。
	所以我们要唤醒线程。IOCP中就用PostQueuedCompletionStatus()函数。这个函数在唤醒线程的时候也可以给线程发送退出信号，线程接收到信号之后就自动退出。那么线程都唤醒了，信号也发出了，我们什么时候关闭IOCP对象呢？显然不能在信号刚发出就释放IOCP对象，这样仍然会造成内存泄露。我们就必须等待线程接受到信号，并且处理了信号，把自己退出，然后才能释放IOCP对象。这里我们采用windows提供的事件机制。退出时，激活事件
	
	//额外要求：满足任意客户端之间的通信。
	
从需求中可知，
属性：
private：
	m_IOCP；
	m_IP;
	m_Port;
	perSocket池指针
	perIO池指针
	
操作：
	LoadSocket();
	InitIOCP();<------getNumOfProcessor();
	BindToLocal(); <---------getLocalIP();setPort();
	PostAccept();
	DoAccpeted();
	PostRecv();
	DoRecved();
	PostSend();
	DoSend();
	
	
前提
perSocket结构
perIO结构
操作类型结构

perSocketContext结构设计：
struct perSocketContext
{
	socket;
	// ... 用户信息
	list；						// 操作链表指针
	static int count; // 计数赋值
	index；						// 下标
	
	perSocketContext()
	{
		socket 初始化；
		链表初始化
		index = count;
	}
	
	~perSocketContext()
	{
		closeSocket;
		delete 链表；
	}
}
perIOContext设计分析：

struct perIOContext
{
	Overlapped；
	socket*；	//用于获取perSocket的内容。
	wsaBUf；
	buf；
	type；		// 操作类型
	
	static int count；
	int index；
}
enume OperatorType
{
	accept，send，recv，NON
}

综合分析上述工作：
包括
	1、初始化工作，这个可以在构造函数中完成。
	2、绑定、监听、启动线程，投递各种操作。
	3、投递的操作完成之后所做的操作。
	4、退出清理，可以在析构函数中完成。
	
阶段二、
又遇到的问题：
1、如何把所有的Socket绑定到IOCP对象？
2、事件机制的原理
3、缓冲区为何要清零？

第一个问题，
最直接的方法自然是所有对象都建立之后，先从perSocket池中取出socket，然后绑定，所有的都绑定完后再全部回池。
另外我们似乎可以把IOCP对象指针做成全局的，只需确定在生成池之前先建立IOCP对象，生成每个persocket对象时绑定的时候绑定。这样就可以一次完成了，代价就是四个字节的全局空间，任何一处的全局空间都应该重视。
第二个问题，
为了更快的认识事件，我们从事件的函数说起。
1、HANDLE WINAPI CreateEvent(
  LPSECURITY_ATTRIBUTES lpEventAttributes,		// 安全属性的结构
  BOOL bManualReset,													// 是否要手动激活
  BOOL bInitialState,													// 设定事件的初始状态，是否有信号。
  LPCTSTR lpName															// 事件名称，便于在其他进程或线程使用
);
创建事件，不过看了这个还是不明所以，再看这个
BOOL WINAPI SetEvent(
  HANDLE hEvent
);
激活事件，也就是让事件变成有信号状态。结合之前的函数，我们应该能推出事件应该有两种状态，激活（有信号）和未激活（无信号）两种状态，我们可以选择手动激活，也可以让他自动激活，另外还可以跨进程使用事件。

激活也就代表着事件发生了，那么我们如何知道事件发生了呢，这就需要我们等着操作系统来告诉我们，看下面两个功能十分特别强大的函数：
DWORD WINAPI WaitForSingleObject(
  HANDLE hHandle,						// 等待对象句柄
  DWORD dwMilliseconds			// 等待时间，超出则返回超时，设为INFINITE（-1），则会一直等下去，设为0,则不等待，直接返回。
);
如果返回WAIT_OBJECT_0，则表示所等待的对象已激活，返回WAIT_TIMEOUT表示等待超时。

DWORD WINAPI WaitForMultipleObjects(
  DWORD nCount,								// 等待对象的个数
  const HANDLE* lpHandles,		// 存放对象句柄的数组
  BOOL bWaitAll,							// 是否等待全部对象返回
  DWORD dwMilliseconds				// 等待时间
);
返回值：WAIT_OBJECT_0，表示已等到了所有对象，WAIT_TIMEOUT超时

他们可以等待对象的类型为：
Change notification 					// 变化通知
Console input 								// 控制台输入
Event 												// 事件
Memory resource notification 	// 内存资源通知
Mutex 												// 互斥体
Process 											// 进程
Semaphore 										// 信号量
Thread 												// 线程
Waitable timer 								// 定时器

分析以下我们这里所要用到的关于事件的内容，首先要生成一个手动激活的无信号的事件，线程中等待事件激活，激活则结束线程。在关闭程序时，我们首先要激活事件，然后等待线程返回。线程返回了我们就可以很轻松的释放其他的资源了。

第三个问题：
在perIo结构中的缓冲区，在操作结束时，是否有必要去清空？
如果我们发送的数据长度都标注的很精准，这似乎也并不是必要的，不过作为一个好的习惯，我们应该把数据清空，以免出现意外的漏洞。

阶段三、
很悲剧的又发现问题了，这次是由多线程引起的。由于我们有两种存储数据的结构，池和链表，那么就有可能是在出池的中间，又有元素要入池。这样就会引起下标的错乱。还有就是出池的中间还有要出池的，入池的中间又有要入池的。这就很容易出问题了。那么如何解决这个问题呢？
脑中一片混乱，那就慢慢尝试吧。
首先对于线程共享资源最常用的就是设置临界区，那么对于取函数和存函数就只能等一个完成之后，另一个操作才能去做。那么同时存和取的操作还是无法完成呀。我******++++――――――===，不是要把我的池给改了吧，把这两个函数合二为一到确实能够解决这个问题。
池的问题先放一下，我们看链表，插入元素到链表中，从链表中删除元素。同样存在上述问题。

分析以下线程同步的四种方法：
临界区：把两个函数整合成一个函数，把函数内容设为临界区。
互斥量：同临界区一样，不过它是内核对象，可以跨进程使用。
信号量:
事件;

新的一天开始了，继续看我们的多线程引发的问题。百度了以下，头都大了，多线程中的数据结构问题不是一个小问题，以后再详细讨论。我们回到原来的问题。
先说一下上面的两个错误，第一个是多线程上的问题，第二个是临界区的问题。
对于第一个，我们从线程的建立开始。
HANDLE WINAPI CreateThread(
  LPSECURITY_ATTRIBUTES lpThreadAttributes,				// 内核对象的安全属性
  SIZE_T dwStackSize,															// 栈空间大小
  LPTHREAD_START_ROUTINE lpStartAddress,					// 线程函数指针
  LPVOID lpParameter,															// 线程函数参数
  DWORD dwCreationFlags,													// 创建后的状态，运行或挂起
  LPDWORD lpThreadId															// 保存线程ID的变量指针
);
执行完这个线程有什么效果呢？
其实就是生成运行一个线程要有的东西。从操作系统上看，它需要一个内核对象便于管理，还需要自己的堆栈空间。(好吧，其实我早就知道了)。对于堆栈空间，我们只用设置好栈空间大小，其他的由操作系统分配完成。然后就是内核对象了，其实它就是一个结构体对象。它需要有哪些内容呢

线程ID，线程函数指针，线程函数参数，线程状态，现在我们能涉及到的就是这些了。对于线程的句柄是由它所在的进程统一管理的。

需要注意的是，线程函数的参数是一个指针类型，如果你要传的数据小于四个字节那就随意强转，保存到参数的位置就行了。而参数较大，必须以指针的形式传入时，就要时刻避免野指针的问题了，传进去的指针所对应的空间必须保证在线程函数运行期间是有效的，且要防止被错误修改。
线程的控制，比如，挂起，睡眠，停止一般没什么问题。有问题一般要出在对共享资源的管理上。

下面说第二个问题，临界区的理解：
一般所说的临界区是指临界区对象。它是一个用户对象。
CRITICAL_SECTION criticalSection;							// 定义临界区对象，方式无所谓
InitializeCriticalSection(&criticalSection);	// 初始化临界区，它是一个函数
EnterCriticalSection(&criticalSection);				// 进入临界区，此时临界区被占用，其他进入临界区的操作就要等待。
LeaveCriticalSection(&criticalSection);				// 离开临界区
DeleteCriticalSection(&criticalSection);			// 删除临界区
他们的返回值都是void。执行EnterCriticalSection(&criticalSection);	这个函数可能使线程陷入等待状态，有的时候并不需要，我们可以用TryEnterCriticalSection()，它的返回值为bool类型，如果进入了临界区则返回true，若其他线程正在使用临界区，则返回false，可以对这两种状态分贝处理，而不必让线程阻塞。

需要说明的是，线程的等待会使线程从用户模式切换到内核模式，频繁的切换对CPU的效率影响是很大的。为了提高关键段的性能，我们可以使用旋转锁功能。他会用一个旋转锁不断的循环，尝试对资源的访问。如果尝试都失败了，那就只能转换到内核模式的等待状态了。

1、windows上所说的对象都是一个结构体。那么我们就来看看这个结构体吧。
typedef struct _RTL_CRITICAL_SECTION {
    PRTL_CRITICAL_SECTION_DEBUG DebugInfo;			// 编译信息？？不知道干什么的

    LONG LockCount;															// 锁定的次数，不知道哪要用。
    LONG RecursionCount;												// 递归次数,字面翻译，不理解
    HANDLE OwningThread;        // 进入临界区的线程句柄
    HANDLE LockSemaphore;				// 锁的信号量，难道信号量也要用这个结构体
    ULONG_PTR SpinCount;        // 找到上面所说的旋转锁是什么玩意了，这是旋转的次数
} RTL_CRITICAL_SECTION, *PRTL_CRITICAL_SECTION;

上面的函数所要修改的属性也就一目了然了。
使用带旋转锁的关键段-的函数：
BOOL InitializeCriticalSectionAndSpinCount( LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount )；
一个是临界区，另一个是旋转次数。
也可重设旋转的次数:
DWORD SetCriticalSectionSpinCount( LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount );
它是怎么旋转的呢？好吧，我根本不关心。它还依赖于内核数，单核根本不旋转。。。。。

还有一个读写锁，原理其实差不多的，
SRWLock 读写锁对象，可以控制线程的读取和写入。
SRWLOCK srwlock；
void InitializeSRWLock( __out PSRWLOCK SRWLock ) 
void AcquireSRWLockExclusive( __inout PSRWLOCK SRWLock )  独占写
void ReleaseSRWLockExclusive( __inout PSRWLOCK SRWLock )  写完释放
void AcquireSRWLockShared( __inout PSRWLOCK SRWLock )  		共享读，自然是避免同时写的。
void ReleaseSRWLockShared( __inout PSRWLOCK SRWLock )  		读结束

线程同步性能排序（由高到低）
volatile读取 -->volatile写入-->Interlocked API(原子方式)-->SRWLock-->关键段-->内核对象

互斥体、信号量、事件都属于内核对象。

走出了这些误区，对我们的池和链表加上临界区其实就已经可以解决问题了。

还回到我们的程序，突然发现，我们链表的功能还远远不够呀，在一个socket断开连接时，我们要把这个socket相关的perSocket回池，perIO回池，删除链表中含有操作的节点，对于已投递出去的只好交给IOCP来处理了，我们似乎管不了。那么我们所需要的操作就是找到所有有操作的节点，然后把操作回池，然后删除节点，节点删完之后就把该perSocket回池。
问题似乎都解决了，现在还会到我们的IOCP模型上。
继续昨天的代码。
思考一个问题，我们需要在哪些代码上添加临界区？
临界区自然是越少越好，越小越好。回到临界区的根本作用，避免多线程对共享资源造成的意外修改。
所以，修改共享资源的代码要进入临界区。对于池，操作只有两种，入和出，加上就OK了。链表的操作比较复杂，插入，查找，删除，由序号查找，删除指定序号处的节点，复原。分析以下我们这里所要进行的操作的关系，查找只是为了删除，并且返回的是节点指针，不必同步，没有用到删除指定位置的节点，由序号查找和复原操作是用在客户端已断开，所有操作均无法完成。所以不必同步。需要同步的就剩下  插入，删除。
考虑一下加临界区的两种方式，在函数内部加，在函数外部（调用函数处）加的区别：
1、多个操作互不相干，只是不能同步进行的，自然是加在内部比较好了，符合越少的原则。
2、一个操作依赖与另一个操作的完成，这些操作可以看作一个整体的，则为整体加临界区，在函数内部加反而是多此一举。
暂时就想到这些了。继续代码去。

周末暂停

新的一天又...美好的开始了。

现在琐碎的事情已经完成了，可以开始我们的操作函数了。

1、投递接受连接操作，参数：根据上面的设计，它只需要一个perIO对象，然后利用acceptEx投递操作，我们看acceptEx的参数就知道它需要什么了。
BOOL AcceptEx(
  SOCKET sListenSocket,		// 侦听socket
  SOCKET sAcceptSocket,		// 与客户端连接的socket
  PVOID lpOutputBuffer,		// 接受缓冲区，存放客户端与主机的地址信息，以及客户端发来的第一条消息
  DWORD dwReceiveDataLength,		// 接受到的数据的长度
  DWORD dwLocalAddressLength,		// 本机地址信息
  DWORD dwRemoteAddressLength,	// 远程客户端信息
  LPDWORD lpdwBytesReceived,		// 函数返回后所接受到的数据的字节数，可以自己验证数据的完成性。
  LPOVERLAPPED lpOverlapped			// Overlapped结构不解释。
);
这些东西我们的perIO里基本都有了，只需再定义一个DWORD类型的变量。
当然的一个好的编程习惯是检查每一步操作的正确性，便于后续的调试与修改。这里我们可以用GetLastError()来获取上一个错误进行检验。

返回值：我们可以返回真或假来表示投递操作是否成功。
好吧我们的投递连接操作就这样了。
2、接收数据操作
这个函数，我们从它的主体说起，也就是WSARecv（）函数。
int WSARecv(
  SOCKET s,									// 所用的socket
  LPWSABUF lpBuffers,				// WSABuf结构体的指针，里面存的是缓冲区的指针和长度。可以理解为缓冲区。
  DWORD dwBufferCount,			// 缓冲区数目。其实是WSABuf的数目，因为上一个参数可以指向一个数组，一般我们设为1就行了
  LPDWORD lpNumberOfBytesRecvd,		// 成功接收到的字节数。
  LPDWORD lpFlags,								// 可以控制调用这个函数时的一些操作，这里先不关心。
  LPWSAOVERLAPPED lpOverlapped,		// 重叠结构。
  LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine		// 回调函数，完成例程里用的，这里用不着。
);

我们需要的函数参数仍然是一个perIO就OK了。
错误检验与返回值与上个函数一样一样的。

3、投递发送操作，要发送数据就首先要有数据呀！！！！
好吧，我们这里就先发送一串接受到的用户输入的字符吧。
那么，他就需要一个IO结构，一个字符串。或者是之前先把字符串放入perIO的缓冲区，这样就仍旧只用一个perIO了。
这里我们按聊天服务器来设定，它不是随意与客户端聊天的，只是在某些特定时候做出些反馈，或者根据客户端发来的指令做一些转发操作。
这些就在接收到数据后做吧
int WSASend(
  SOCKET s,							// 发送数据的socket
  LPWSABUF lpBuffers,		// 缓冲区
  DWORD dwBufferCount,	// 1
  LPDWORD lpNumberOfBytesSent,		// 成功发送的字节数
  DWORD dwFlags,									// 标志
  LPWSAOVERLAPPED lpOverlapped,		// 重叠结构
  LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine		// NULL
);

后面的同上了。

要投递的操作基本完成了，那么这些操作被DMA做完后，要怎么处理呢。

1.x 连接完成。首先把接受到的客户端信息保存在perSocket中。我们可以假定客户端连接成功后会吧自己的ID发过来，这样我们就可以根据ID组成一个聊天组。两个人，我一个群。扯远了
我们先完成一个客户端与服务器之间的通信。ok，保存客户端地址信息，为该客户端投递接受数据操作。这里我们先不接收用户发来的第一组数据。

2.x 接收数据完成。首先要对数据进行处理，我们用于接收的缓冲区都是char*，也就是接受到的都是字符串。首先就要把这些字符串转换为我们想要的类型，然后根据这些数据的内容做相应的操作。这里似乎还不需要，为了测试，我们在收到了数据之后就跟客户端发一句，“收到了，亲”。那么我们需要的操作就是显示数据，投递一个发送数据的操作，然后再把该接收数据的操作投递出去。用之前记得清理缓冲区。

3.x 发送数据完成，发送完了么，好像完了就行了。我。。。，忽略了一个问题。投递出去的操作是要做记录的。因为，客户端断连时，我们必须把为它所投递的空间收回来，要不然内存泄漏将会是一个很大的问题。那么第一步接收数据的操作投递出去，要把该操作的perIO结构指针放入该persocket的链表中。，第二步把链表中的接受数据操作删除，发送数据完成后要把发送数据的操作放入链表，然后再把接收操作放到链表中。这里就要把，发送数据的操作删除掉。

如果该客户端断连了，就要把连表中的这些元素全部释放掉，oh，NO，是放回我们的池中。

断连怎么检测？发送一个空数据就行了，发送成功了返回0，发送不成功返回-1。
什么时候检测，真不好确定呀。我们用下面的几种方法比较一下：
1、定时检测，每隔10s或30s检测一下，这对于那些连接很稳定的似乎根本没必要，并且对效率的影响很大。
2、投递的操作多余五个的时候检测，似乎也不太好，服务器一般不向客户端发送数据。很可能它已断连很久了才会被发现。
3、突然想到我们可以在GetQueuedComplationStatus()等到的操作不仅有执行完成，正常返回的；也有出现异常，异常返回的。我们只需对这些异常返回的检测是否客户端出现问题就行了，因为操作投递出去超出等待的时间后操作会异常返回，错误是等待超时。那么根据它他返回的错误调用也就OK了，如果客户端断开了，你知道要干什么。
4、GetQueuedComplationStatus()中的一个参数返回的是传送的字节数，我们有它知道客户端是否断开。实际上，在既不是发送操作，又不是接受操作，而该操作返回0个字节就表示它已经断开了。这是windows已经帮我们设定好的。

线程函数的说明：
主体是一个死循环，就是为了等待退出事件。通过接收到的操作的结果做相应的处理。

在之前的分析中，我认为线程函数设为全局函数或者静态成员函数都是可以的。但是传参之后，突然发现我们的成员变量都是私有的，为了能让成员函数正常访问，我们必须把它写成友元函数或者静态成员函数。

各种操作，以及错误处理，还有客户端异常退出的处理。优点乱，现在我们重新理一下工作线程的内容。
首先我们工作线程就是一个死循环，他在等待着关闭事件的触发。在循环内首先要有GetQueuedComplationStatus（）函数，线程也就等待在这里，每次接受到操作，线程就从它下面执行，直到下次循环到这里。在接收到完成的操作后，首先看它是不是退出线程的。也就是我们退出时为激活线程所投递的操作。然后再判断get函数的返回结果。

为了弄清楚GetQueued函数的返回值，啃了一会msdn，
大致翻译如下：
如果完成端口操作队列中的一个IO操作成功完成了，那么这个操作就从操作队列中出队，函数返回非0。操作结果信息被存储在lpNumberOfBytesTransferred，lpCompletionKey，and lpOverlapped中。

如果*lpOverlapped是NULL，那么就没有操作从完成端口中返回。函数的返回值就是0。函数不会存储相关信息。可以用GetLastError获取更多错误。如果因为超时函数没有出队一个完成的操作，获取到的错误就是WAIT_TIMEOUT。

如果* lpOverlapped不为NULL并且函数从完成端口的一个失败I / O操作完成包，返回值是零。在变量的函数存储的信息指向lpNumberOfBytesTransferred，lpCompletionKey，and lpOverlapped的指向。为了获得更多的错误信息，调用GetLastError。

现在，我们就可以根据它的返回值来安排我们的代码：
有错误的时候先检查是否是因为超时，如果不是，则输出错误码，否则进行正确结果的处理即可。
如果发送或接受的结果是0个字节，我们也认为客户端退出了。//看了别人代码

2014年12月16日 17:50:16.代码草稿完成了。
里面又调出几个BUG，
倒着回忆吧，记不得了。。
1、在使用临界区的时候，一不小心把return写到了临界区里面，结果可想而知，函数退出后，其他线程进不去，本线程只进不出。好像是第二次进就出错了，有空再研究一下，同一线程多次进入而不离开的后果。
2、createIOComplationPort()函数的参数写错了，浪费了十多分钟，才想起来，不过msdn倒用的更熟了。
3、代码的组织结构，本想在构造函数中只做数据的初始化，加载动态库放到函数中做，没想到对象初始化的时候就已经用到了套接字库，大意了，这个属于考虑不当。

暂时就这些了，期待发现新的错误。
截图留念：

又发现了一点东西：当客户端异常退出时，操作会返回，错误码为：64，ERROR_NETNAME_DELETED

做完又出了一个Bug，链表中每次删除元素时就会出现问题，昨天找了两个多小时，一直没发现。睡醒又看了一个多小时。不得不承认，我写的两万多字的设计仍旧是一堆漏洞呀，自己感觉考虑的已经很完善了，做起来才发现是漏洞百出。不说了，设计链表的时候，竟然没考虑到删除的元素是尾节点。设计的每一步都是相辅相成的，认真做好每一步，才能得到自己想要的结果。


总结：身体力行，多巧代码

2014年12月19日 09:27:08
Bug总是存在的，现在说一说昨天的Bug，
先说自己的，由于对客户端断连时的处理不当，导致客户端异常断开之后，socket和Overlapped虽然回池，但再取出来之后无法使用，之后添加了清理工作后，socket的断连重用，Overlapped的清理，
出现原因：池的设计不当，没有考虑到回池时的清理工作。
结论：使用前的初始化和使用后的清理工作都是很重要的，不可忽视。
再说两个同学的，一个堆损坏，对于这个问题，学会了一个工具的使用pageheap，某些时候他可以帮你很准确的定位到出问题的代码处。
堆损坏的原因：堆的边界被破坏。一个是多次释放，一个是无意修改。用了半天时间才找到一个链表设计中的问题。
结论：使用工具很轻松，但因为工具所引起的原因也是很令人烦恼的，所以使用之前，请确保对该工具的原理很熟悉，并且，该工具对于当下情况是适用的。
第二个，数组越界，把后面的值修改了，并且修改的一个很常用的值，于是在多线程中就引起了许多莫名其妙，匪夷所思的问题。
结论：查错能力很重要，但避免错误的能力更重要。对于这种很容易犯的错误一定要多注意。
查错方法：
1、监视内存
2、用工具监视内存（设置数据断点）。

昨天的说完了，说一下今天又发现的，bug是层出不穷，不过这也说明它更加完美了。
在一个发送数据的操作投递完成后，我们假设，数据开始发送，操作就返回了，那么，在返回之后，处理DoSend的过程中（也就是把IO回池），如果客户端断开了，那么为他投递的recv操作会立刻失败返回。我们就要清理这个socket所投递的所有操作。同时还有一个问题需要注意，那就是，他们是在两个线程中执行的，清除所有操作的过程中，如果DoSend结束，io回池，但它还没有从链表中删除，清除所有操作时，会再次把它回池，于是问题就出来了，大量操作执行时，回池的iO会多出来。。。当然实际的运行过程是更多变的，详细看代码中的clearSocket函数和DoSend函数。

先写一下脑中的大体思路，然后做比较：
1、把DoSend所做回池的处理加临界区，临界区内判断是否已情况socket相关信息。
2、为每一个perIO结构加一个是否在池中的状态变量，每次执行回池之前都先判断一下它是否在池中，不在，则状态改为在池中，执行回池。若在池中，则不执行回池。

余窃以为不用临界区可以在一定程度上提高效率，不过代价就是空间的占用了。

13:47:05
bug还是会出现，那就说明之前发现的问题并不是关键问题。多线程的设计真不是一件简单的事情。许多问题都不容易发现。
现在为所有可能出问题的代码处添加错误处理。


为了修改的简洁，我们按第一种修改。现在似乎运行着不会出错了，不过，运行时CPU满载，必须对链表结构做出修改。
这里就先不做了，我们重点在测试IOCP通信，现在实现我的第二个目标，实现私聊和群聊。

对于知识点的验证：
1、查资料，与自己的情况比较
2、自己验证，先把自己想到的情况，但又不清楚结果的，就可以运用已有的知识去验证未知的。


投递的操作的三种状态：
1、立即完成。比如发送操作一般都是立即完成的，但它要进IO完成操作队列，如果有线程空闲则调用线程进行处理
2、挂起状态。操作在未完成IO队列中。表示操作正在执行或还未执行
以上两种情况应该是用Overlapped中的Internal表明的，经测试，未完成的操作Internal的值为0x103，完成后为0。
这样GetOverlappedResult()的实现机制也就一目了然了。
printf("DoRecv Internal == %p\n",pPerIOForRecv->overlapped.Internal);
printf("PostRecv Internal == %p\n",pPerIOForRecv->overlapped.Internal);
printf("PostSend Internal == %p\n",pPerIOForSend->overlapped.Internal);
3、失败。由于各种原因，投递的操作执行失败则返回错误。

在运行多线程时所触发的断言：
在之前的代码中，断言的触发多是在插入链表的操作中。原因自然是在多线程中临界区的使用不当引起的。

1、在PostRecv中，函数可能立即返回，也就是网卡缓冲区中已经有了客户端发来的信息，当投递处操作时，函数立即返回。
那么由于这个操作返回，有空闲的线程时，IOCP就启动线程执行DoRecv操作。那么postRecv操作中，把节点插入链表和DoRecv中把节点从链表中删除的执行先后顺序就可能存在多样性。
2、在PostSend中，一般函数都是立即返回。那么同样，后面的把节点插入链表和把节点从链表中删除就会存在问题。
>>客户端强制断开连接时的处理：
3、postSend中，操作已投递出去，但是客户端突然断开了连接，那么就会有线程把这个socket所有的操作相关的信息都清除掉。此时把节点插入链表的操作就会出错。必定触发断言。
4、DoSend过程中，如果客户端突然断开连接，那么把节点从连表中删除的过程就会触发断言。

解决方案：
很容易发现这些问题大部分都是在插入链表和删除节点的过程中发生的，那么，尽量少的把数据放入链表，即使要插入链表，就把操作都放入临界区，放的时候，是在链表函数内部加临界区，还是在调用链表函数的地方插入临界区呢。
分情况说明：
1、recv操作，对于每个客户端必有一个，且始终有一个。当然可以有多个，但个数都是保持不变的。所以，在接受连接的时候把它放入链表中，之后不做处理，一直到客户端退出时释放用于接收数据的perIO结构。
2、重点问题就出在send中，因为send操作个数是不确定的，也是不好控制的额，我们必须把它时刻保存。

一种方法是，在send与插入链表的操作放入临界区中，那么一旦有发送数据，链表中就必定有与该操作对应的perIO。那么执行了一半，立即返回或断连的情况就都可以应付了。

另一种方法是，把插入链表的操作放入缓冲区中，同时加一个操作非空的判断，确保其他操作完后后判断是否要插入链表，或者插入链表中之后再进行其他操作。如果发出操作之后，因为立即返回清空，或者断连清空，那么就不放入链表。当然DoSend中，从链表中删除操作是找不到要删除的元素的，因为它还没有加入链表，这个错误正常的，可以不作处理。

3、在执行DoSend的过程中，客户端断开连接。
dosend所做的操作--把IO回池，删除节点
断开后的clear操作，把socket相关的所有IO回池，把socket信息还原，投递断连重用socket操作。

那么,进入DoSend之后，客户端断连，clear函数执行完之后，因为所有IO已回池，DoSend再回池一次，就会引起回池的IO增多...如果已经回池，但链表中的数据还没删除，那么，clear函数就会出错。

同样，clear的过程中，如果执行DoSend，也会回池增多。
那么加临界区的时候IO回池和从链表中删除必须同步进行，即是，删除失败也要放在一个临界区内。

IOCP类有一个临界区，每个池有一个临界区，每个链表有一个临界区，这么多的临界区会不会出现死锁？要解决这个问题，只要把所有的临界区所使用的其他临界区罗列一遍，就很容易从逻辑上判断出他们是否会形成死锁。
举例来说：
PostRecv中，IOCP-->perIO-->leave-->leave
postSend中，IOCP-->link-->leave-->leave
doSend中,IOCP-->IO池-->leave-->leave
clear中，IOCP-->IO-->leave-->leave
显然是不会有死锁的。到现在为止，常见的错误终于修复完成了，当然它仍旧只是一个学习测试代码。如果要实用一点，可以加入一些防攻击机制。比如，在一个IP不断投递连接，当连接次数超过一定数量时，我们就可以把这个socket断开。并禁止该IP的连接。

当用户登录过多时，socket池中没有可用的socket时，用户应该进入排队等待状态。







